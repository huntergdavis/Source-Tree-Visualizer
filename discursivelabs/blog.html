<!--#include virtual="before_content.html" -->
		<!--Public Domain Image of Training class from http://commons.wikimedia.org/wiki/File:Computer_class.jpg -->
		<img src="./images/training.jpg" width="50%"/>
		<br/>
		<h2>Virtual Machine Storage - the problems with existing systems</h2>
		One of the nice things about running your own business is the choices you get to make during your infrastructure development.  Unfortunately, sometimes the choices presented to you are not sufficient for everyday use.  We are lucky in our industry in that a healthy lack of choice can present a healthy dose of opportunity.  Such was the case with our virtual machine repository.  
		
		There are a number of problems inherrent in the design of mainstream source repositories that make them an imperfect solution for large binary files, in this case virtual machines.  One can maximize the effectiveness of these scm solutions by various means of trickery (non-encrypted and static sized images, zero'd out free space clusters, etc), but they are all fighting the same issue.  Source code repositories are just not designed for large binary images.  Git creates a completely new copy of each iterative virtual machine, and SVN is terribly touchy about CRC checks.  Other VMs are only as good as their storage backend, which are provably less efficient that SVN and xdelta.  What is needed is a virtual machine repository, capable of efficiently caching large binaries and efficiently storing small changes.  This was the impetus behind the vmrepo: protocol and storage backend.
		
		One of the decisions we made early on in our general software development process was to abstract the hardware out of the equation as much as possible.  Long fans of virtual machines, we decided to use a custom virtual machine per project.  This includes all the software tools, login auth, project files, etc needed to completely develop or deploy one of our projects.  This helps to remove any hardware issues from the equation.  A new developer can pull a VM from a repository in a few minutes, and be completely ready to develop or deploy a product.
		
		An immediate benefit to a custom backend is in the hashing of data blocks.  Our custom hashing and storage protocol is custom tailored to maximize the efficiency of virtual machine storage.  Storing many copies of the same virtual machine with many small changes does not equate to an entire copy of the virtual machine being created, and the developer is free to commit virtual machine images daily or hourly (can you imagine the storage cost overhead on a tradition system?  INSANE).    
		
		Another benefit of this is it aides greatly in the tech support aspect of software development.  If a customer is running a specific version of a product, a tech support agent or programmer can pull the VM image that was used to create that exact version of the product.  This simplifies the debugging of any deployment issues, and allows one to build the exact version with a bug patch, if required.    
		
		Yet another benifit of iterative VMs is that they simplify a number of training situations.  Want to train your customers on a specific version of your software, on a unified platform?  Deploy a VM to them.  Want to show a unified desktop to all training members?  Share a unified desktop screen with all trainees, or switch control to each user individually for maximum impact.
		
		Hopefully this has given you some insight into the sort of problems we face, and the solutions we create everyday here at Discursive Labs.  In the future, I hope to expound greatly on topics of software and product development, and hopefully shine a light on some of the most talented developers I know, my employees.
	/Hunter
		<p>	
<!--#include virtual="after_content.html" -->
 